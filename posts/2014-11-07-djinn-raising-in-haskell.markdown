---
title: Магия Haskell - вызываем джина
description: Генерирование кода функции по ее типу с помощью джина (djinn)
tags: haskell, djinn, windows
---

В мире Haskell есть много интересных пакетов, программ, которых не встретишь в мире ООП ввиду их функциональной направленности.
Примером одной из таких программ является [djinn](https://hackage.haskell.org/package/djinn), которую создал Lennart Augustsson 
([исходный код](https://github.com/augustss/djinn)). То, что она делает, похоже на уличную магию и, видимо, производит наибольший
вау-эффект на тех, кто недавно вошел в мир функционального программирования. Программа по заданному типу функции пытается сгенерировать
код этой функции, если это вообще возможно. Лучше наверное сказать, что она, исходя из типов входных параметров, пытается найти
такую трансформацию, которая бы в итоге возвращала значение нужного типа. Лучше всего это объяснить на примерах.

## Как вызывать джина без лампы?

Для начала установим [djinn](https://hackage.haskell.org/package/djinn). Актуальной версией на момент написания является 2014.9.7. 
Проблем с установкой под Windows быть не должно (обычно, если какая-либо программа на Haskell не собирается, то, как правило, не 
собирается именно под Windows, это если авторы использовали что-то из мира Linux, а именно в том мире в большинстве случаев 
обитают хаскеллисты).

Обновляем список пакетов и устанавливаем djinn:

```
> cabal update
> cabal install djinn
```

Все пакеты под Windows устанавливаются в `%APPDATA%\cabal`, устанавливаемые исполняемые файлы оказываются в каталоге `%APPDATA%\cabal\bin`,
поэтому лучше всего добавить этот каталог в `%PATH%`, если этого еще не сделали. Все кто против системы или просто лентяи могут призвать 
джина путем запуска:

```
> %APPDATA%\cabal\bin\djinn.exe
```

## Загадываем желания

Теперь, когда джин вызван, можно загадывать желания. Рассмотрим команды, которые он умеет выполнять.

### `<sym> ? <type>`

Эта команда используется чтобы сгенерировать функцию с именем `<sym>` по ее типу `<type>`. Djinn знает о типах функций,
о кортежах, о Either, Maybe, (), можно также объявить и передать синонимы типов, тип данных. Вот список синонимов типов,
типов данных и классов типов определенных в окружении djinn сразу после запуска (позже можно определить свои):

```
Djinn> :e
```

```{.haskell}
data () = ()
data Either a b = Left a | Right b
data Maybe a = Nothing | Just a
data Bool = False | True
data Void
type Not x = x -> Void
class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
class Eq a where (==) :: a -> a -> Bool
```

Если функция может быть найдена, она будет выведена в виде кода на Haskell. Например, сгенерируем функцию, которая 
принимает параметр типа `a`{.haskell} и возвращает результат того же типа `a`{.haskell}:

```
Djinn> f ? a->a
```

```{.haskell}
f :: a -> a
f a = a
```

Это было просто. Пример чуть сложнее, где из внутренних кортежей выберем элементы нужных нам типов.

```
Djinn> sel ? ((a,b),(c,d)) -> (b,c)
```

```{.haskell}
sel :: ((a, b), (c, d)) -> (b, c)
sel ((_, a), (b, _)) = (a, b)
```

А слабо из типа `a`{.haskell} вывести тип `b`{.haskell}?

```
Djinn> convert ? a->b
-- convert cannot be realized.
```

"Ага-aa!!!" — укоризненно сказали суровые сибирские лесорубы.

Стоит также отметить, что если может быть несколько имплементаций, то будет выведена только одна из них. Например,

```
Djinn> f ? a->a->a
```

```{.haskell}
f :: a -> a -> a
f _ a = a
```

Однако, можно включить вывод нескольких решений командой:

```
Djinn> :s +multi
```

Тогда результат команды

```
Djinn> f ? a->a->a
```

будет таким

```{.haskell}
f :: a -> a -> a
f _ a = a
-- or
f a _ = a
```

### `<sym> :: <type>`

Этой командой мы можем добавить в окружение djinn новую функцию, которая может быть использована при генерации результирующей
функции. Например,

```
Djinn> foo :: Int -> Char
Djinn> bar :: Char -> Bool
Djinn> f ? Int -> Bool
```

Error: Undefined type Int

```{.haskell}
f :: Int -> Bool
f a = bar (foo a)
```