<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="author" content="Dmitrij Koniajev" />		
        <title>Имплементация HyperLogLog на C# - Непутёвые заметки Димчанского</title>
		<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
		<link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
		
		<script type="text/javascript">
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		  ga('create', 'UA-41629923-3', 'auto');
		  ga('send', 'pageview');

		</script>	
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
		<div id="wrapper">
			<div id="header">
				<div class="header-logo"><h1><a href="../../../../../">Непутёвые заметки Димчанского</a></h1></div>
				<div class="header-links">
					<a href="https://twitter.com/dimchansky"><i class="fa fa-twitter fa-fw fa-2x"></i></a>
					<a href="https://github.com/dimchansky"><i class="fa fa-github fa-fw fa-2x"></i></a>
					<a href="https://www.linkedin.com/in/dimchansky"><i class="fa fa-linkedin fa-fw fa-2x"></i></a>
					<a href="https://www.youtube.com/user/Dimchansky"><i class="fa fa-youtube fa-fw fa-2x"></i></a>
					<a href="../../../../../atom.xml"><i class="fa fa-rss fa-fw fa-2x"></i></a>
				</div>
			</div>	

			<div id="content">
				<article>
<header>
<h1>Имплементация HyperLogLog на C#</h1>

<p>Дата: <strong>October 26, 2014</strong></p>
<p>Метки: <a href="../../../../../tags/cardinality-estimation.html">cardinality-estimation</a>, <a href="../../../../../tags/big-data.html">big-data</a>, <a href="../../../../../tags/HyperLogLog.html">HyperLogLog</a>, <a href="../../../../../tags/C%23.html">C#</a>, <a href="../../../../../tags/FNV.html">FNV</a>, <a href="../../../../../tags/MurmurHash3.html">MurmurHash3</a></p>
</header>

<section>
<h2 id="описание-реализованных-методов">Описание реализованных методов</h2>
<p>Исходя из <a href="../../../../../posts/2014/10/20/cardinality-estimation-using-hyperloglog/#HyperLogLog">описания алгоритма HyperLogLog</a> его имплементация не должна представлять особых проблем. Ниже представлено <a href="#HyperLogLogCode">переложение алгоритма HyperLogLog на C#</a>.</p>
<ul>
<li>Конструктор <code class="sourceCode cs"><span class="kw">public</span> <span class="fu">HyperLogLog</span>(<span class="dt">int</span> k)</code> принимает параметр k=4..16 такое, что \( m={ 2 }^{ k } \) - число байтовых регистров, которое будет выделено в оперативной памяти для приблизительного подсчета числа уникальных элементов лежащего в интервале \( \left[ 0,10^9 \right] \). При этом стандартная ошибка при оценке числа уникальных элементов будет составлять \( \frac { 1.04 }{ \sqrt { { 2 }^{ k } } } \).</li>
<li>Метод <code class="sourceCode cs"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">Add</span>(<span class="dt">int</span> hash)</code> принимает 32-битный хеш элемента из набора, в котором нужно оценить число уникальных элементов. В главе <a href="../../../../../posts/2014/10/20/cardinality-estimation-using-hyperloglog/#hashing">о хешировании</a> можно прочесть слова Дональда Кнута, который говорит, что на практике возможно создать хеш-функцию, которая бы из неслучайных данных создавала данные хоть и не совсем случайные, но очень похожие на случайные. Этому стоит уделить особое внимание, потому что недостаточно хорошая хеш-функция, которая будет генерировать хеши не похожие на случайные, сведет весь алгоритм на нет. В реализации метода можно можно увидеть, что после получения индекса регистра из хеша (по первым k битам) далее ведется подсчет младших нулевых битов, а не старших, как это описано в алгоритме. На самом деле совершенно нет разницы, считаем мы последовательность нулевых битов в старших битах или в младших, ведь хеш - это <em>как бы</em> случайное число.</li>
<li>Метод <code class="sourceCode cs"><span class="kw">public</span> <span class="dt">double</span> <span class="fu">EstimateCount</span>()</code> позволяет произвести оценку числа уникальных элементов, хеши которых были ранее добавлены через вызов метода <code class="sourceCode cs"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">Add</span>(<span class="dt">int</span> hash)</code>.</li>
<li>Наконец метод <code class="sourceCode cs"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">UnionWith</span>(HyperLogLog other)</code> позволяет объединить уникальные элементы из разных наборов. Это может быть полезно, если, например, исходная выборка была разбита на несколько частей и для каждой части независимо производилась оценка числа уникальных элементов. Очень важно помнить, что объединяемые объекты класса <code class="sourceCode cs">HyperLogLog</code> должны использовать то же самое число регистров (параметр k должен быть одним и тем же) и для добавляемых элементов должна использоваться одна и та же хеш-функция. Нельзя использовать для двух разных объектов класса <code class="sourceCode cs">HyperLogLog</code> две разные пусть и очень хорошие хеш-функции, т.к. в результате в лучшем случае получится сумма уникальных элементов из каждого набора по отдельности, в худшем случае просто чепуха.</li>
</ul>
<h2 id="проверяем-правильность-работы-алгоритма-на-случайных-данных">Проверяем правильность работы алгоритма на случайных данных</h2>
<p>Прежде чем пробовать алгоритм на каких-то реальных данных, проверим, насколько хорошо он работает на случайных. То есть вместо хешей будем подавать случайные хеши (предполагая, что коллизий будет мало) и проверять на сколько алгоритм ошибается в оценке.</p>
<p>Для проверки возьмем криптографический генератор случайных чисел, не будем полагаться на простой random. Напишем такой генератор бесконечного списка случайных 32-битных чисел:</p>
<pre class="sourceCode cs"><code class="sourceCode cs">IEnumerable&lt;<span class="dt">int</span>&gt; <span class="fu">GetRandomInts</span>()
{
    <span class="dt">var</span> rng = <span class="kw">new</span> System.<span class="fu">Security</span>.<span class="fu">Cryptography</span>.<span class="fu">RNGCryptoServiceProvider</span>();
    <span class="dt">var</span> intBytes = <span class="kw">new</span> <span class="dt">byte</span>[<span class="dv">4</span>];
    
    <span class="kw">while</span>(<span class="kw">true</span>)
    {
        rng.<span class="fu">GetBytes</span>(intBytes);
        <span class="dt">var</span> rndInt = BitConverter.<span class="fu">ToInt32</span>(intBytes, <span class="dv">0</span>);     
        <span class="kw">yield</span> <span class="kw">return</span> rndInt;
    }
}</code></pre>
<p>Прогоним теперь через объект класса <code class="sourceCode cs">HyperLogLog</code> наши случайные числа и в определенных точках сверим оценку с числом поданых случайных чисел:</p>
<pre class="sourceCode cs" id="testCode"><code class="sourceCode cs"><span class="co">// здесь будут точки, в которых будем производить оценку</span>
<span class="dt">var</span> ticks = <span class="kw">new</span> HashSet&lt;<span class="dt">int</span>&gt;(Enumerable
    .<span class="fu">Range</span>(<span class="dv">1</span>, <span class="dv">8</span>)
    .<span class="fu">Select</span>(i =&gt; (<span class="dt">int</span>)Math.<span class="fu">Pow</span>(<span class="dv">10</span>,i))
    .<span class="fu">SelectMany</span>(i =&gt; <span class="kw">new</span>[]{i, <span class="dv">5</span>*i}));
    
<span class="dt">var</span> hll = <span class="kw">new</span> <span class="fu">HyperLogLog</span>(<span class="dv">10</span>); <span class="co">// k = 10</span>
<span class="dt">var</span> cnt = <span class="dv">0</span>;                   <span class="co">// число добавленных хешей</span>

Console.<span class="fu">WriteLine</span>(<span class="st">&quot;| Разных значений | Оценка     | Ошибка,% |&quot;</span>);
Console.<span class="fu">WriteLine</span>(<span class="st">&quot;|----------------:|-----------:|:--------:|&quot;</span>);
<span class="kw">foreach</span> (var hash <span class="kw">in</span> <span class="fu">GetRandomInts</span>().<span class="fu">Take</span>(<span class="dv">100000000</span>))
{
    hll.<span class="fu">Add</span>(hash); <span class="co">// добавляем хеш</span>
    cnt++;         <span class="co">// увеличиваем число добавленных хешей</span>
    
    <span class="kw">if</span> (!ticks.<span class="fu">Contains</span>(cnt)) { <span class="kw">continue</span>; }
    <span class="co">// производим оценку и вычисляем ошибку</span>
    <span class="dt">var</span> estimateCount = hll.<span class="fu">EstimateCount</span>();
    Console.<span class="fu">WriteLine</span>(<span class="st">&quot;|{0,17}|{1,12:0.00}|{2,10:0.0000}|&quot;</span>, cnt, estimateCount, Math.<span class="fu">Abs</span>(cnt - estimateCount)/cnt*<span class="fl">100.0</span>);
}</code></pre>
<p>При k=10 получается такая таблица (стандартная ошибка \( \frac { 1.04 }{ \sqrt { { 2 }^{ 10 } } } = 3.25\)%):</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,05</td>
<td align="center">0,4915</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">51,26</td>
<td align="center">2,5239</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">104,12</td>
<td align="center">4,1183</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">502,30</td>
<td align="center">0,4596</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">993,76</td>
<td align="center">0,6242</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">4934,58</td>
<td align="center">1,3083</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">9654,82</td>
<td align="center">3,4518</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">50896,97</td>
<td align="center">1,7939</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">101884,92</td>
<td align="center">1,8849</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">509183,34</td>
<td align="center">1,8367</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">1023285,78</td>
<td align="center">2,3286</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">4934955,44</td>
<td align="center">1,3009</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">10073259,12</td>
<td align="center">0,7326</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">49928262,24</td>
<td align="center">0,1435</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">97500823,59</td>
<td align="center">2,4992</td>
</tr>
</tbody>
</table>
<p>При k=16 получается такая таблица (стандартная ошибка \( \frac { 1.04 }{ \sqrt { { 2 }^{ 16 } } } = 0.40625\)%):</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,00</td>
<td align="center">0,0076</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">50,02</td>
<td align="center">0,0382</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">100,08</td>
<td align="center">0,0764</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">501,92</td>
<td align="center">0,3834</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">1002,63</td>
<td align="center">0,2631</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">5010,77</td>
<td align="center">0,2153</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">10027,46</td>
<td align="center">0,2746</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">50124,56</td>
<td align="center">0,2491</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">99690,22</td>
<td align="center">0,3098</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">502979,77</td>
<td align="center">0,5960</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">997461,99</td>
<td align="center">0,2538</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">4984715,12</td>
<td align="center">0,3057</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">9982520,07</td>
<td align="center">0,1748</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">50020851,75</td>
<td align="center">0,0417</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">100022493,99</td>
<td align="center">0,0225</td>
</tr>
</tbody>
</table>
<p>Как видим ошибки оценок довольно неплохо укладываются в теорию. Теперь можно взять какой-нибудь набор данных и выбрать хеш-функцию для него.</p>
<h2 id="выбираем-функцию-хеширования">Выбираем функцию хеширования</h2>
<p>Как выше было сказано в описании, выбору хеш-функции следует уделить особое внимание по нескольким причинам:</p>
<ol style="list-style-type: decimal">
<li>Если хеш-функция выдает не достаточно случайные хеши для начальных данных, вычисленная оценка будет скорее всего очень сильно занижать реальное значение так, что погрешность может достигать почти 100% делая вычисления бессмысленными.</li>
<li>Если статистика собирается на длительном промежутке времени, нельзя будет на ходу просто поменять хеш-функцию на другую более хорошую, т.к. иначе уже собранную статистику придется сбросить в ноль.</li>
</ol>
<p>Для начала опробуем хеш-функцию <a href="https://ru.wikipedia.org/wiki/FNV">FNV-1a</a> на 32-битных целых числах.</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">static</span> <span class="dt">int</span> <span class="fu">Fnv1AHash</span>(<span class="dt">byte</span>[] bytes)
{
    <span class="kw">unchecked</span>
    {
        <span class="dt">const</span> <span class="dt">int</span> fnv32Offset = (<span class="dt">int</span>)<span class="dv">2166136261</span>;
        <span class="dt">const</span> <span class="dt">int</span> fnv32Prime = <span class="dv">16777619</span>;
        <span class="dt">int</span> hash = fnv32Offset;

        <span class="kw">foreach</span> (var t <span class="kw">in</span> bytes)
        {
            hash = hash ^ t;
            hash *= fnv32Prime;

        }
        <span class="kw">return</span> hash;
    }
}</code></pre>
<p>Тепер для чисел целых 32-битных чисел начиная с 0 применим эту хеш-функцию. В <a href="#testCode">коде</a>, который мы применяли для тестирования алгоритма на случайных числах заменим строку:</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">foreach</span> (var hash <span class="kw">in</span> <span class="fu">GetRandomInts</span>().<span class="fu">Take</span>(<span class="dv">100000000</span>))</code></pre>
<p>на</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                        .<span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">100000000</span>)           <span class="co">// все целые числа, начиная с нуля в количестве 100000000</span>
                        .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                        .<span class="fu">Select</span>(Fnv1AHash))            <span class="co">// применим к каждому массиву хеш-функцию</span></code></pre>
<p>При k=10 получим такие результаты:</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,05</td>
<td align="center">0,4915</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">51,26</td>
<td align="center">2,5239</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">105,23</td>
<td align="center">5,2260</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">549,08</td>
<td align="center">9,8159</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">1056,33</td>
<td align="center">5,6332</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">6634,90</td>
<td align="center">32,6980</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">11027,98</td>
<td align="center">10,2798</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">41923,40</td>
<td align="center">16,1532</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">54234,00</td>
<td align="center">45,7660</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">126984,56</td>
<td align="center">74,6031</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">353391,49</td>
<td align="center">64,6609</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">6233096,62</td>
<td align="center">24,6619</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">13254027,76</td>
<td align="center">32,5403</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">51887411,47</td>
<td align="center">3,7748</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">81864421,81</td>
<td align="center">18,1356</td>
</tr>
</tbody>
</table>
<p>Как видим, хеш-функция для наших входных данных (последовательности целых чисел начиная с нуля) не достаточно хороша, т.к. ошибка очень большая получается. Что можно сделать? Можно попробовать сделать два раунда хеширования - сначала хешируем входные данные, затем хешируем полученный хеш:</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                        .<span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">100000000</span>)           <span class="co">// все целые числа, начиная с нуля в количестве 100000000</span>
                        .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                        .<span class="fu">Select</span>(Fnv1AHash)             <span class="co">// применим к каждому массиву хеш-функцию</span>
                        .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем каждый хеш в массив из 4-х байтов</span>
                        .<span class="fu">Select</span>(Fnv1AHash))            <span class="co">// применим к каждому массиву снова хеш-функцию</span></code></pre>
<p>Теперь при k=10 результаты заметно улучшились:</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,05</td>
<td align="center">0,4915</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">50,21</td>
<td align="center">0,4223</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">100,80</td>
<td align="center">0,8026</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">486,10</td>
<td align="center">2,7810</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">967,70</td>
<td align="center">3,2300</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">4899,62</td>
<td align="center">2,0076</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">9788,63</td>
<td align="center">2,1137</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">47822,37</td>
<td align="center">4,3553</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">97091,62</td>
<td align="center">2,9084</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">474394,98</td>
<td align="center">5,1210</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">974288,21</td>
<td align="center">2,5712</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">5439552,49</td>
<td align="center">8,7910</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">9955849,45</td>
<td align="center">0,4415</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">49659117,73</td>
<td align="center">0,6818</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">94593348,50</td>
<td align="center">5,4067</td>
</tr>
</tbody>
</table>
<p>Многие эксперименты показывают, что <a href="http://en.wikipedia.org/wiki/MurmurHash">MurmurHash3</a> хоть и не является криптографически-безопасной хеш-функцией, но обладает хорошим распределением, обладает высокой скоростью и устойчивостью к коллизиям. За основу была взята <a href="https://gist.github.com/automatonic/3725443">эта реализация</a> и немного <a href="#MurmurHash3">допилена напильником</a>.</p>
<p>После замены</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                        .<span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">100000000</span>)           <span class="co">// все целые числа, начиная с нуля в количестве 100000000</span>
                        .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                        .<span class="fu">Select</span>(MurMurHash3.<span class="fu">Hash</span>))     <span class="co">// применим к каждому массиву хеш-функцию</span></code></pre>
<p>были полученные такие результаты при k=10:</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,05</td>
<td align="center">0,4915</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">51,26</td>
<td align="center">2,5239</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">101,91</td>
<td align="center">1,9067</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">499,04</td>
<td align="center">0,1927</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">1001,71</td>
<td align="center">0,1706</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">5101,16</td>
<td align="center">2,0233</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">9625,14</td>
<td align="center">3,7486</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">51753,74</td>
<td align="center">3,5075</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">98546,11</td>
<td align="center">1,4539</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">487898,62</td>
<td align="center">2,4203</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">984749,69</td>
<td align="center">1,5250</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">5078692,01</td>
<td align="center">1,5738</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">10075100,60</td>
<td align="center">0,7510</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">51533442,86</td>
<td align="center">3,0669</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">101786556,87</td>
<td align="center">1,7866</td>
</tr>
</tbody>
</table>
<p>При k=16:</p>
<table>
<thead>
<tr class="header">
<th align="right">Разных значений</th>
<th align="right">Оценка</th>
<th align="center">Ошибка,%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="right">10,00</td>
<td align="center">0,0076</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">50,02</td>
<td align="center">0,0382</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">100,08</td>
<td align="center">0,0764</td>
</tr>
<tr class="even">
<td align="right">500</td>
<td align="right">497,89</td>
<td align="center">0,4227</td>
</tr>
<tr class="odd">
<td align="right">1000</td>
<td align="right">998,57</td>
<td align="center">0,1431</td>
</tr>
<tr class="even">
<td align="right">5000</td>
<td align="right">4979,47</td>
<td align="center">0,4106</td>
</tr>
<tr class="odd">
<td align="right">10000</td>
<td align="right">9961,07</td>
<td align="center">0,3893</td>
</tr>
<tr class="even">
<td align="right">50000</td>
<td align="right">50000,06</td>
<td align="center">0,0001</td>
</tr>
<tr class="odd">
<td align="right">100000</td>
<td align="right">99580,45</td>
<td align="center">0,4196</td>
</tr>
<tr class="even">
<td align="right">500000</td>
<td align="right">497924,41</td>
<td align="center">0,4151</td>
</tr>
<tr class="odd">
<td align="right">1000000</td>
<td align="right">996976,43</td>
<td align="center">0,3024</td>
</tr>
<tr class="even">
<td align="right">5000000</td>
<td align="right">5003075,05</td>
<td align="center">0,0615</td>
</tr>
<tr class="odd">
<td align="right">10000000</td>
<td align="right">9991536,18</td>
<td align="center">0,0846</td>
</tr>
<tr class="even">
<td align="right">50000000</td>
<td align="right">50289746,12</td>
<td align="center">0,5795</td>
</tr>
<tr class="odd">
<td align="right">100000000</td>
<td align="right">100782312,74</td>
<td align="center">0,7823</td>
</tr>
</tbody>
</table>
<p>Таким образом MurmurHash3 оказалась действительно неплохой хеш-функцией в нашем случае.</p>
<h2 id="объединяем-результаты">Объединяем результаты</h2>
<p>Теперь наглядно убедимся, что можно объединять результаты оценки уникальных элементов. Для этого возьмем числа из интервала [0, 9999] произведем оценку числа уникальных элементов на этом интервале, затем то же самое отдельно сделаем для интервала [5000, 14999], после чего объединим результаты. Т.е. в итоге у нас должно получиться порядка 15000 уникальных элементов:</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> hll1 = <span class="kw">new</span> <span class="fu">HyperLogLog</span>(<span class="dv">10</span>);
<span class="dt">var</span> hll2 = <span class="kw">new</span> <span class="fu">HyperLogLog</span>(<span class="dv">10</span>); 

<span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                    .<span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">10000</span>)                <span class="co">// все целые числа, начиная с нуля в количестве 10000</span>
                    .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                    .<span class="fu">Select</span>(MurMurHash3.<span class="fu">Hash</span>))     <span class="co">// применим к каждому массиву хеш-функцию                        </span>
{
    hll1.<span class="fu">Add</span>(hash);     
}

<span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                    .<span class="fu">Range</span>(<span class="dv">5000</span>, <span class="dv">10000</span>)            <span class="co">// все целые числа, начиная с 5000 в количестве 10000</span>
                    .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                    .<span class="fu">Select</span>(MurMurHash3.<span class="fu">Hash</span>))     <span class="co">// применим к каждому массиву хеш-функцию                        </span>
{
    hll2.<span class="fu">Add</span>(hash);     
}

Console.<span class="fu">WriteLine</span>(<span class="st">&quot;Уникальных элементов на интервале 0-9999: {0:0.00}&quot;</span>, hll1.<span class="fu">EstimateCount</span>());
Console.<span class="fu">WriteLine</span>(<span class="st">&quot;Уникальных элементов на интервале 5000-14999: {0:0.00}&quot;</span>, hll2.<span class="fu">EstimateCount</span>());

hll1.<span class="fu">UnionWith</span>(hll2); <span class="co">// в hll1 будет объединение всех уникальных элементов</span>
Console.<span class="fu">WriteLine</span>(<span class="st">&quot;Уникальных элементов на интервале 0-14999: {0:0.00}&quot;</span>, hll1.<span class="fu">EstimateCount</span>());</code></pre>
<p>В результате получаем:</p>
<pre><code>Уникальных элементов на интервале 0-9999: 9625,14
Уникальных элементов на интервале 5000-14999: 10013,74
Уникальных элементов на интервале 0-14999: 15139,33</code></pre>
<p>Что нисколько не отличается, если бы мы произвели измерения на одном объекте:</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> hll = <span class="kw">new</span> <span class="fu">HyperLogLog</span>(<span class="dv">10</span>);

<span class="kw">foreach</span> (var hash <span class="kw">in</span> Enumerable
                    .<span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">15000</span>)               <span class="co">// все целые числа, начиная с нуля в количестве 15000</span>
                    .<span class="fu">Select</span>(BitConverter.<span class="fu">GetBytes</span>) <span class="co">// конвертируем в массив из 4-х байтов</span>
                    .<span class="fu">Select</span>(MurMurHash3.<span class="fu">Hash</span>))     <span class="co">// применим к каждому массиву хеш-функцию                        </span>
{
    hll.<span class="fu">Add</span>(hash);      
}

Console.<span class="fu">WriteLine</span>(<span class="st">&quot;Уникальных элементов на интервале 0-14999: {0:0.00}&quot;</span>, hll.<span class="fu">EstimateCount</span>());</code></pre>
<p>И в этом случае получили абсолютно тот же самый результат:</p>
<pre><code>Уникальных элементов на интервале 0-14999: 15139,33</code></pre>
<p>Это не должно нас удивлять, т.к. хеши одинаковых элементов совпадают до бита, и попадают в одни и те же регистры, а максимум последовательности нулей в хешах можно искать в произвольном порядке и в результате получим одно и то же число. Это все равно что искать максимальное число в массиве - можно поделить его на несколько частей, параллельно там найти максимумы, а потом среди максимумов найти один единственный максимум. То же самое происходит в нашем случае на уровне отдельных регистров.</p>
<h2 id="MurmurHash3">Имплементация хеш-функции MurmurHash3 на C#</h2>
<table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> MurMurHash3
{
    <span class="dt">const</span> <span class="dt">uint</span> seed = <span class="dv">0</span>;
 
    <span class="kw">public</span> <span class="kw">static</span> <span class="dt">int</span> <span class="fu">Hash</span>(<span class="dt">byte</span>[] bytes)
    {
        <span class="kw">unchecked</span>
        {
            <span class="dt">const</span> <span class="dt">uint</span> c1 = <span class="bn">0xcc9e2d51</span>;
            <span class="dt">const</span> <span class="dt">uint</span> c2 = <span class="bn">0x1b873593</span>;
    
            <span class="dt">uint</span> h1 = seed;
            <span class="dt">uint</span> k1 = <span class="dv">0</span>;        
    
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; bytes.<span class="fu">Length</span>; i = i + <span class="dv">4</span>)
            {
                <span class="dt">var</span> chunkLength = bytes.<span class="fu">Length</span> - i;
                <span class="kw">switch</span>(chunkLength)
                {
                    <span class="kw">case</span> <span class="dv">4</span>:
                        k1 = (<span class="dt">uint</span>)(bytes[i] | bytes[i + <span class="dv">1</span>] &lt;&lt; <span class="dv">8</span> | bytes[i + <span class="dv">2</span>] &lt;&lt; <span class="dv">16</span> | bytes[i + <span class="dv">3</span>] &lt;&lt; <span class="dv">24</span>);
    
                        k1 *= c1;
                        k1 = <span class="fu">rotl32</span>(k1, <span class="dv">15</span>);
                        k1 *= c2;
    
                        h1 ^= k1;
                        h1 = <span class="fu">rotl32</span>(h1, <span class="dv">13</span>);
                        h1 = h1 * <span class="dv">5</span> + <span class="bn">0xe6546b64</span>;
                        <span class="kw">break</span>;
                    <span class="kw">case</span> <span class="dv">3</span>:
                        k1 = (<span class="dt">uint</span>)(bytes[i] | bytes[i + <span class="dv">1</span>] &lt;&lt; <span class="dv">8</span> | bytes[i + <span class="dv">2</span>] &lt;&lt; <span class="dv">16</span>);
                        k1 *= c1;
                        k1 = <span class="fu">rotl32</span>(k1, <span class="dv">15</span>);
                        k1 *= c2;
                        h1 ^= k1;
                        <span class="kw">break</span>;
                    <span class="kw">case</span> <span class="dv">2</span>:
                        k1 = (<span class="dt">uint</span>) (bytes[i] | bytes[i + <span class="dv">1</span>] &lt;&lt; <span class="dv">8</span>);
                        k1 *= c1;
                        k1 = <span class="fu">rotl32</span>(k1, <span class="dv">15</span>);
                        k1 *= c2;
                        h1 ^= k1;
                        <span class="kw">break</span>;
                    <span class="kw">case</span> <span class="dv">1</span>:
                        k1 = (<span class="dt">uint</span>)(bytes[i]);
                        k1 *= c1;
                        k1 = <span class="fu">rotl32</span>(k1, <span class="dv">15</span>);
                        k1 *= c2;
                        h1 ^= k1;
                        <span class="kw">break</span>;              
                }           
            }
                    
            h1 ^= (<span class="dt">uint</span>)bytes.<span class="fu">Length</span>;
            h1 = <span class="fu">finalizer32</span>(h1);
    
            <span class="kw">return</span> (<span class="dt">int</span>)h1;         
        }
    }
    
    <span class="kw">private</span> <span class="kw">static</span> <span class="dt">uint</span> <span class="fu">rotl32</span>(<span class="dt">uint</span> x, <span class="dt">byte</span> r)
    {
        <span class="kw">return</span> (x &lt;&lt; r) | (x &gt;&gt; (<span class="dv">32</span> - r));
    }
 
    <span class="kw">private</span> <span class="kw">static</span> <span class="dt">uint</span> <span class="fu">finalizer32</span>(<span class="dt">uint</span> h)
    {
        <span class="kw">unchecked</span>
        {
            h ^= h &gt;&gt; <span class="dv">16</span>;
            h *= <span class="bn">0x85ebca6b</span>;
            h ^= h &gt;&gt; <span class="dv">13</span>;
            h *= <span class="bn">0xc2b2ae35</span>;
            h ^= h &gt;&gt; <span class="dv">16</span>;
            <span class="kw">return</span> h;           
        }
    }
}</code></pre></td></tr></table>
<h2 id="HyperLogLogCode">Имплементация алгоритма HyperLogLog на C#</h2>
<table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">sealed</span> <span class="kw">class</span> HyperLogLog
{
    <span class="dt">const</span> <span class="dt">double</span> TwoPowOf32 = <span class="bn">0x100000000</span>;

    <span class="kw">private</span> <span class="kw">readonly</span> <span class="dt">int</span> _kComplement;
    <span class="kw">private</span> <span class="kw">readonly</span> <span class="dt">int</span> _m;
    <span class="kw">private</span> <span class="kw">readonly</span> <span class="dt">double</span> _alphaM2;
    <span class="kw">private</span> <span class="kw">readonly</span> <span class="dt">byte</span>[] _registerM;

    <span class="kw">public</span> <span class="fu">HyperLogLog</span>(<span class="dt">int</span> k)
    {
        <span class="kw">if</span> (k &lt; <span class="dv">4</span> || k &gt; <span class="dv">16</span>)
        {
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentOutOfRangeException</span>(<span class="st">&quot;k&quot;</span>, k, <span class="st">&quot;k must be between 4 and 16 inclusive&quot;</span>);
        }

        _kComplement = <span class="dv">32</span> - k;
        _m = <span class="dv">1</span> &lt;&lt; k;
        <span class="dt">var</span> alphaM = _m == <span class="dv">16</span>
            ? <span class="fl">0.673</span>
            : _m == <span class="dv">32</span>
                ? <span class="fl">0.697</span>
                : _m == <span class="dv">64</span>
                    ? <span class="fl">0.709</span>
                    : <span class="fl">0.7213</span>/(<span class="fl">1.0</span> + <span class="fl">1.079</span>/_m);
        _alphaM2 = alphaM * _m * _m;
        _registerM = <span class="kw">new</span> <span class="dt">byte</span>[_m];
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Add</span>(<span class="dt">int</span> hash)
    {
        var idx = (<span class="dt">uint</span>) hash &gt;&gt; _kComplement;
        <span class="dt">var</span> rank = Math.<span class="fu">Min</span>(_kComplement, <span class="fu">CountTrailingZeroBits</span>(hash)) + <span class="dv">1</span>;
        _registerM[idx] = (<span class="dt">byte</span>) Math.<span class="fu">Max</span>(_registerM[idx], rank);
    }

    <span class="kw">public</span> <span class="dt">double</span> <span class="fu">EstimateCount</span>()
    {
        <span class="dt">double</span> c = <span class="fl">0.0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; _m; i++)
        {
            c += <span class="fl">1.0</span> / Math.<span class="fu">Pow</span>(<span class="dv">2</span>, _registerM[i]);
        }

        <span class="dt">double</span> estimate = _alphaM2 / c;

        <span class="kw">if</span> (estimate &lt;= (<span class="fl">2.5</span> * _m))
        {
            <span class="dt">int</span> v = <span class="dv">0</span>;
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; _m; i++)
            {
                <span class="kw">if</span> (_registerM[i] == <span class="dv">0</span>) { v++; }
            }

            <span class="kw">if</span> (v &gt; <span class="dv">0</span>)
            {
                estimate = _m * Math.<span class="fu">Log</span>((<span class="dt">double</span>)_m / v);
            }
        }
        <span class="kw">else</span> <span class="kw">if</span> (estimate &gt; (TwoPowOf32 / <span class="fl">30.0</span>))
        {
            estimate = -TwoPowOf32 * Math.<span class="fu">Log</span>(<span class="fl">1.0</span> - (estimate / TwoPowOf32));
        }

        <span class="kw">return</span> estimate;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">UnionWith</span>(HyperLogLog other)
    {
        <span class="kw">if</span> (other == <span class="kw">null</span>)
        {
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentNullException</span>(<span class="st">&quot;other&quot;</span>);
        }

        <span class="kw">if</span> (other.<span class="fu">_m</span> != _m)
        {
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">InvalidOperationException</span>(<span class="st">&quot;The number of counters must be the same.&quot;</span>);
        }

        <span class="kw">if</span> (other == <span class="kw">this</span>)
        {
            <span class="kw">return</span>;
        }

        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; _m; i++)
        {
            _registerM[i] = Math.<span class="fu">Max</span>(_registerM[i], other.<span class="fu">_registerM</span>[i]);
        }
    }

    <span class="kw">private</span> <span class="kw">static</span> <span class="dt">int</span> <span class="fu">CountTrailingZeroBits</span>(<span class="dt">int</span> v)
    {
        <span class="kw">if</span> ((v &amp; <span class="bn">0x1</span>) == <span class="dv">1</span>) { <span class="kw">return</span> <span class="dv">0</span>; }
        
        <span class="dt">int</span> c = <span class="dv">1</span>;
        <span class="kw">if</span> ((v &amp; <span class="bn">0xffff</span>) == <span class="dv">0</span>) { v &gt;&gt;= <span class="dv">16</span>; c += <span class="dv">16</span>; }
        <span class="kw">if</span> ((v &amp; <span class="bn">0xff</span>) == <span class="dv">0</span>) { v &gt;&gt;= <span class="dv">8</span>; c += <span class="dv">8</span>; }
        <span class="kw">if</span> ((v &amp; <span class="bn">0xf</span>) == <span class="dv">0</span>) { v &gt;&gt;= <span class="dv">4</span>; c += <span class="dv">4</span>; }
        <span class="kw">if</span> ((v &amp; <span class="bn">0x3</span>) == <span class="dv">0</span>) { v &gt;&gt;= <span class="dv">2</span>; c += <span class="dv">2</span>; }
        c -= v &amp; <span class="bn">0x1</span>;
        <span class="kw">return</span> c;
    }
}</code></pre></td></tr></table>
</section>
</article>
<div class="likebutton">
	<div class="socbuttons">
		<div class="twitter">
			<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://dimchansky.github.io/posts/2014/10/26/hyperloglog-csharp-implementation/" data-text="Имплементация HyperLogLog на C#" data-via="dimchansky" data-hashtags="cardinality-estimation, big-data, HyperLogLog, C#, FNV, MurmurHash3">Tweet</a>
			<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
		</div>
		<div class="facebook">
			<iframe style="border: none; overflow: hidden; width: 135px; height: 20px;" src="http://www.facebook.com/plugins/like.php?href=http://dimchansky.github.io/posts/2014/10/26/hyperloglog-csharp-implementation/&layout=button_count&show_faces=false&width=135&action=like&colorscheme=light&height=20" height="240" width="320" frameborder="0" scrolling="no"></iframe>
		</div>
		<div class="vkontakte"></div>
		<div class="google">
			<!-- Place this tag in your head or just before your close body tag. -->
			<script src="https://apis.google.com/js/platform.js" async defer>
			  {lang: 'ru'}
			</script>

			<!-- Place this tag where you want the +1 button to render. -->
			<div class="g-plusone" data-size="medium" data-annotation="inline" data-width="300"></div>		
		</div>
	</div>
</div>
<section>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'dimchansky'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>		
</section>

			</div>
		
			<div id="footer">
				Site proudly generated by
				<a href="http://jaspervdj.be/hakyll">Hakyll</a>
			</div>		
		</div>		
    </body>
</html>
