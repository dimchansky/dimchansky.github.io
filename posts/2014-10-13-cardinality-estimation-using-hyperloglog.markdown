---
title: Оценка приблизительного числа уникальных элементов в наборе данных
description: Применения алгоритма HyperLogLog для приблизительного вычисления числа уникальных элементов в наборе данных
tags: cardinality-estimation, big-data, hyperloglog
---

Предположим, что у нас имеется очень большой набор данных с дубликатами, который не помещается в оперативную память. 
Нам необходимо подсчитать число уникальных элементов в этом наборе. Можно было бы, конечно, отсортировать данные на диске и подсчитать точно,
но мы этого делать не хотим, нам бы хотелось подсчитать это хотя бы приблизительно за один проход. В таком случае мы сможем даже на живом потоке 
данных в режиме реального времени вычислять число полученных уникальных элементов, например, число уникальных IP адресов.

## Простой интуитивный подход

**ВСЕ ТАБЛИЦЫ ПЕРЕДЕЛАТЬ: ИНТЕРВАЛ ДОЛЖЕН БЫТЬ 0..2^k-1 !!!**

Для начала упростим нашу задачу и предположим, что наши данные - это равномерно распределенные в заранее известном интервале целые числа. Попробуем 
сгенерировать несколько наборов данных с одинаковым числом уникальных случайных чисел в каждом наборе. Пусть в каждом наборе будет 9 уникальных
случайных чисел равномерно распределенных в интервале [0, 10000], сгенерируем 20 таких наборов:

|      |     1|     2|     3|     4|     5|     6|     7|     8|     9|
|:----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|
| **1**|  2060|  4422|  5582|  5589|  7263|  7680|  8174|  9061|  9776|
| **2**|   303|  2737|  2919|  4673|  4695|  6327|  8624|  9822|  9954|
| **3**|   326|  3146|  5263|  6772|  7000|  8169|  8481|  9341|  9920|
| **4**|   811|  1871|  2972|  4533|  5468|  6427|  6876|  7630|  9886|
| **5**|   303|  1189|  2734|  3431|  3810|  5051|  7160|  9071|  9575|
| **6**|  1468|  2213|  3371|  4101|  4572|  4880|  6198|  7187|  7948|
| **7**|  1949|  2184|  6249|  6798|  7354|  8255|  8583|  8782|  8954|
| **8**|   865|  1701|  2192|  4814|  6441|  8268|  8386|  8965| 10000|
| **9**|  1009|  1255|  1891|  6522|  7185|  7197|  7291|  8095|  9052|
|**10**|  3255|  4684|  4768|  5408|  6711|  7645|  7937|  8092|  8335|
|**11**|  1868|  2225|  2867|  2950|  3326|  5228|  6634|  8206|  9376|
|**12**|   665|   685|  2213|  6246|  6304|  6931|  9001|  9277|  9288|
|**13**|   939|  1069|  1480|  1491|  4906|  6099|  6776|  6785|  9531|
|**14**|    50|   623|  2254|  2816|  3609|  5699|  6182|  7050|  8505|
|**15**|   570|  2803|  2805|  3871|  5066|  5227|  5316|  9586|  9889|
|**16**|  1041|  1307|  4019|  4961|  6132|  6997|  7424|  8465|  9334|
|**17**|  1727|  1845|  2507|  5697|  6091|  6154|  6851|  8306|  9972|
|**18**|   634|   777|  2637|  5164|  5681|  5687|  6460|  8426|  9702|
|**19**|  1557|  3016|  5130|  5529|  5754|  6425|  6725|  8137|  9946|
|**20**|   644|   716|  1508|  2163|  2302|  4469|  4511|  4657|  4831|
|**avg**| **1102.2**| **2023.2**| **3267.65**| **4675.9**| **5482.95**| **6440.2**| **7178.75**| **8246.3**| **9187.7**|

В последней строке мы вычислили среднее значение в каждом столбике. Посмотрим на поведение чисел в каждом столбике.
От набора к набору числа в отдельно взятом столбце менялись довольно сильно, но их среднее сходится ко вполне конкретному числу.
Средние значения по столбцу имеют тенденцию с одинаковым расстоянием друг от друга заполнять весь интервал [0, 10000]. Если бы мы взяли не 20 выборок,
а, например, 100000, то мы бы получили следующие средние значения по столбцу:

|      |     1|     2|     3|     4|     5|     6|     7|     8|     9|
|:----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|
|**avg** | **999.73**| **2001.79**| **2998.35**| **3998.86**| **4999.21**| **5996.86**| **6994.35**| **7992.96**| **8998.46**|

Как несложно заметить, среднее значение в первом столбце равно шагу, с которым заполняется весь интервал [0, 10000]. Таким образом,
если бы кто-то сгенерировал похожую таблицу и сказал бы нам среднее значение первого столбца, то мы бы могли оценить число уникальных
элементов, которое было в каждом наборе. Для этого мы бы просто максимальное возможное значение на интервале поделили бы на среднее
значение первого столбца (как шаг сетки) и отняли единицу. В нашем случае, при 100000 выборок, получается оценка в 10000/999.73 - 1 = 9,003 уникальных 
элементов в каждой выборке.

Можно так же сказать иначе, что среднее значение первого столбца есть ни что иное как среднее значение минимальных элементов из каждой выборки. Т.е. мы
просто берем минимальные элементы из каждой выборки и находим их среднее.


|      |                      1|   2|   3|   4|   5|   6|   7|   8|   9| max leading zeros|
|:----:|----------------------:|---:|---:|---:|---:|---:|---:|---:|---:|:----------------:|
| **1**| 2060 = **00**100000001100 (2)| (1)| (1)| (1)| (1)| (1)| (1)| (0)| (0)|                 2|
| **2**| 303 = **00000**100101111 (5)| (2)| (2)| (1)| (1)| (1)| (0)| (0)| (0)|                 5|
| **3**| 326 = **00000**101000110 (5)| (2)| (1)| (1)| (1)| (1)| (0)| (0)| (0)|                 5|
| **4**| 811 = **0000**1100101011 (4)| (3)| (2)| (1)| (1)| (1)| (1)| (1)| (0)|                 4|
| **5**| 303 = **00000**100101111 (5)| (3)| (2)| (2)| (2)| (1)| (1)| (0)| (0)|                 5|
| **6**| 1468 = **000**10110111100 (3)| (2)| (2)| (1)| (1)| (1)| (1)| (1)| (1)|                 3|
| **7**| 1949 = **000**11110011101 (3)| (2)| (1)| (1)| (1)| (0)| (0)| (0)| (0)|                 3|
| **8**| 865 = **0000**1101100001 (4)| (3)| (2)| (1)| (1)| (0)| (0)| (0)| (0)|                 4|
| **9**| 1009 = **0000**1111110001 (4)| (3)| (3)| (1)| (1)| (1)| (1)| (1)| (0)|                 4|
|**10**| 3255 = **00**110010110111 (2)| (1)| (1)| (1)| (1)| (1)| (1)| (1)| (0)|                 2|
|**11**| 1868 = **000**11101001100 (3)| (2)| (2)| (2)| (2)| (1)| (1)| (0)| (0)|                 3|
|**12**| 665 = **0000**1010011001 (4)| (4)| (2)| (1)| (1)| (1)| (0)| (0)| (0)|                 4|
|**13**| 939 = **0000**1110101011 (4)| (3)| (3)| (3)| (1)| (1)| (1)| (1)| (0)|                 4|
|**14**| 50 = **00000000**110010 (8)| (4)| (2)| (2)| (2)| (1)| (1)| (1)| (0)|                 8|
|**15**| 570 = **0000**1000111010 (4)| (2)| (2)| (2)| (1)| (1)| (1)| (0)| (0)|                 4|
|**16**| 1041 = **000**10000010001 (3)| (3)| (2)| (1)| (1)| (1)| (1)| (0)| (0)|                 3|
|**17**| 1727 = **000**11010111111 (3)| (3)| (2)| (1)| (1)| (1)| (1)| (0)| (0)|                 3|
|**18**| 634 = **0000**1001111010 (4)| (4)| (2)| (1)| (1)| (1)| (1)| (0)| (0)|                 4|
|**19**| 1557 = **000**11000010101 (3)| (2)| (1)| (1)| (1)| (1)| (1)| (1)| (0)|                 3|
|**20**| 644 = **0000**1010000100 (4)| (4)| (3)| (2)| (2)| (1)| (1)| (1)| (1)|                 4|
|**avg**|                       |    |    |    |    |    |    |    |    |          **3.85**|

2^(14-3.85) = 1136.2

Что нам это дает? Ведь в исходной постановке задачи у нас есть всего одна выборка, хоть и очень большая, к тому же данные у нас скорее всего
распределены не равномерно, хотя мы и можем сказать, каким числом данные ограничены сверху. Например, если говорить об IP адресах, то понятно,
что нам достаточно 4-х байтов или 32 битов, чтобы представить все возможные значения адресов, однако IP адреса по конкретному региону 
будут скорее всего сосредоточены в каком-то узком диапазоне этих значений и никак не будут распределены равномерно по всему диапазону.