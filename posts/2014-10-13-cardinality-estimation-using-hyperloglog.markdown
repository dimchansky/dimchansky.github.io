---
title: Оценка приблизительного числа уникальных элементов в наборе данных
description: Применения алгоритма HyperLogLog для приблизительного вычисления числа уникальных элементов в наборе данных
tags: cardinality-estimation, big-data, hyperloglog
---

Предположим, что у нас имеется очень большой набор данных с дубликатами, который не помещается в оперативную память. 
Нам необходимо подсчитать число уникальных элементов в этом наборе. Можно было бы, конечно, отсортировать данные на диске и подсчитать точно,
но мы этого делать не хотим, нам бы хотелось подсчитать это хотя бы приблизительно за один проход. В таком случае мы сможем даже на живом потоке 
данных в режиме реального времени вычислять число полученных уникальных элементов, например, число уникальных IP адресов.

## Простой интуитивный подход

Для начала упростим нашу задачу и предположим, что наши данные - это равномерно распределенные в заранее известном интервале целые числа. Попробуем 
сгенерировать несколько наборов данных с одинаковым числом уникальных случайных чисел в каждом наборе. Пусть в каждом наборе будет 7 уникальных
случайных чисел равномерно распределенных в интервале [0, 65535] (16 бит), сгенерируем 20 таких наборов:

|       |1|2|3|4|5|6|7|
|:-----:|------:|------:|------:|------:|------:|------:|------:|
|**1**|13502|36579|36627|47595|50333|53564|59377|
|**2**|17937|19130|28978|30625|30769|41461|64064|
|**3**|1990|20617|44379|53536|56516|64366|65231|
|**4**|2138|34490|45063|45871|55577|61211|65005|
|**5**|5315|12263|19475|29709|35836|42119|64785|
|**6**|1991|22488|24969|33104|46921|50001|62747|
|**7**|7796|9622|17920|22096|29963|52085|59447|
|**8**|12773|14504|26874|31979|40621|47102|57553|
|**9**|14313|40951|44548|48195|54094|56244|58678|
|**10**|5674|11150|14364|42212|54186|54957|58749|
|**11**|6614|31546|42742|47167|47781|53048|65534|
|**12**|8226|12394|21332|31248|35441|47084|59321|
|**13**|30696|43977|50102|52011|53031|54624|61442|
|**14**|14582|18790|19332|21796|34261|43476|53779|
|**15**|4490|12246|14505|40935|41313|45419|60793|
|**16**|4359|6158|7010|9771|44466|58989|60863|
|**17**|9703|14772|32153|37346|39968|44407|62458|
|**18**|333|4083|18458|23654|40513|46201|55737|
|**19**|18371|25371|33198|34258|34837|62821|64802|
|**20**|3736|6826|18386|32511|40183|48649|55470|
|**avg**|9226.95|19897.85|28020.75|35780.95|43330.50|51391.40|60791.75|

В последней строке мы вычислили среднее значение в каждом столбике. Посмотрим на поведение чисел в каждом столбике.
От набора к набору числа в отдельно взятом столбце менялись довольно сильно, но их среднее сходится ко вполне конкретному числу.
Средние значения по столбцу имеют тенденцию с одинаковым расстоянием друг от друга заполнять весь интервал [0, 65535]. Если бы мы взяли не 20 выборок,
а, например, 100000, то мы бы получили следующие средние значения по столбцу:

|       |1|2|3|4|5|6|7|
|:-----:|------:|------:|------:|------:|------:|------:|------:|
|**avg**|8181.31|16384.70|24554.46|32773.65|40939.51|49098.50|57330.43|

Как несложно заметить, среднее значение в первом столбце равно шагу, с которым заполняется весь интервал [0, 65535]. Таким образом,
если бы кто-то сгенерировал похожую таблицу и сказал бы нам среднее значение первого столбца, то мы бы могли оценить число уникальных
элементов, которое было в каждом наборе. Для этого мы бы просто максимальное возможное значение на интервале поделили бы на среднее
значение первого столбца (как шаг сетки) и отняли единицу. В нашем случае, при 100000 выборок, получается оценка в \\( \\frac { 65535 }{ 8181.31 } - 1 = 7.01 \\) уникальных 
элементов в каждой выборке.

Можно так же сказать иначе, что среднее значение первого столбца есть ни что иное как среднее значение минимальных элементов из каждой выборки. Т.е. мы
просто берем минимальные элементы из каждой выборки и находим их среднее.

Что нам это дает? Ведь в исходной постановке задачи у нас есть всего одна выборка, хоть и очень большая, к тому же данные у нас скорее всего
распределены не равномерно, хотя мы и можем сказать, каким числом данные ограничены сверху. Например, если говорить об IP адресах, то понятно,
что нам достаточно 4-х байтов или 32 битов, чтобы представить все возможные значения адресов, однако IP адреса по конкретному региону 
будут скорее всего сосредоточены в каком-то узком диапазоне этих значений и никак не будут распределены равномерно по всему диапазону.

"It is theoretically impossible to define a hash function that creates random data from non-random data in actual files. 
But in practice it is not difficult to produce a pretty good imitation of random data."
Knuth, D. E. The Art of Computer Programming, 2nd ed., vol. 3: Sorting and Searching. Addison-Wesley, 1998


|       |1|2|3|4|5|6|7|max. leading zero bits|
|:-----:|------:|------:|------:|------:|------:|------:|------:|:----------------:|
|**1**|(13502 = b**00**11010010111110) 2|0|0|0|0|0|0|2|
|**2**|(17937 = b**0**100011000010001) 1|1|1|1|1|0|0|1|
|**3**|(1990 = b**00000**11111000110) 5|1|0|0|0|0|0|5|
|**4**|(2138 = b**0000**100001011010) 4|0|0|0|0|0|0|4|
|**5**|(5315 = b**000**1010011000011) 3|2|1|1|0|0|0|3|
|**6**|(1991 = b**00000**11111000111) 5|1|1|0|0|0|0|5|
|**7**|(7796 = b**000**1111001110100) 3|2|1|1|1|0|0|3|
|**8**|(12773 = b**00**11000111100101) 2|2|1|1|0|0|0|2|
|**9**|(14313 = b**00**11011111101001) 2|0|0|0|0|0|0|2|
|**10**|(5674 = b**000**1011000101010) 3|2|2|0|0|0|0|3|
|**11**|(6614 = b**000**1100111010110) 3|1|0|0|0|0|0|3|
|**12**|(8226 = b**00**10000000100010) 2|2|1|1|0|0|0|2|
|**13**|(30696 = b**0**111011111101000) 1|0|0|0|0|0|0|1|
|**14**|(14582 = b**00**11100011110110) 2|1|1|1|0|0|0|2|
|**15**|(4490 = b**000**1000110001010) 3|2|2|0|0|0|0|3|
|**16**|(4359 = b**000**1000100000111) 3|3|3|2|0|0|0|3|
|**17**|(9703 = b**00**10010111100111) 2|2|1|0|0|0|0|2|
|**18**|(333 = b**0000000**101001101) 7|4|1|1|0|0|0|7|
|**19**|(18371 = b**0**100011111000011) 1|1|0|0|0|0|0|1|
|**20**|(3736 = b**0000**111010011000) 4|3|1|1|0|0|0|4|
|**avg**| | | | | | | |2.9|

\\[ { 2 }^{ 2.9 }=7.46 \\]